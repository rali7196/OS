Rehan Ali<br>
CSE 143
Programming Assingment 1 Design 
April 18th, 2024

# Design

## Alarm Clock 
### Data Structures Created

While I did not create any new data structures for part 1 of this assignment, I created 1 new data structure called 
```
thread\_time\_left
```
that had 4 attributes for part 2: elem, sleep\_ticks, my\_thread, and ticks\_at\_calltime. This was a new data structure I created in the timer.h file, as it is used in the timer.c file exclusively. The elem attribute is necessary for this data structure to be placed in the list object found within pintos, the sleep ticks attribute is a uint64\_t to store the amoutn of ticks that the thread is supposed to sleep for, the my\_thread attribute is used to reference the thread that is supposed to be sleeping, and the ticks\_at\_calltime is used to reference the amount of ticks that have passed since the thread started sleeping. 

### Algorithms Used

To create a more efficient thread\_sleep function, I developed my own algorithm that takes inspiration from the semaphores found within sync.h. Firstly, I create a global static list of the aforementioned thread\_time\_left objects to store all of the threads sleeping. I then initialize this list in the timer\_init() function to initialize the list at the start of the program. Now, there are two functions that need to be modified: timer\_sleep() and timer\_interrupt(). 

#### Timer\_Sleep()

The changes I made to this function were rather simple. First, I instantiated a thread\_time\_left struct and filled it out with the appropriate values, with the current ticks going into ticks\_at\_calltime, the argument of thread\_sleep() going into sleep\_ticks, the current thread going into the my\_thread attribute, and an initialized list\_elem pointer for the elem attribute. Then, I needed to disable interrupts to then block the current thread, and then reenable interrupts to preserve the functionality of the OS. As this is only meant to sleep a thread, the changes to this are rather simple. Moving on, I will now discuss the changes made in the timer interrupt handler.

#### Timer\_Interrupt()
The majority of the changes I made were here, as I needed a different way of keeping track of the time that did not involve busy-waiting. Much like its predecessor, this function first starts by incrementing the amount of ticks that have passed via 
```
tick++; 
thread_tick();
``` 
Then, my logic comes into play. Every tick, I iterate through the list I made earlier that stores all of the thread\_time\_left objects. Then I use the following calculation to check if a thread should be woken back up:
```
timer_ticks() - curr->ticks_at_calltime >= curr->sleep_ticks)
``` 
where timer\_ticks() is the current amount of ticks that have passed since the operating system booted, and curr is the current thread\_time\_left object that is being operated on. By taking the difference of timestamps of when the thread started sleeping and what the current time stamp is, we can find out the amount of time that the thread has been sleeping. Then, we can compare it to the amount of time it is supposed to be sleeping for to determine whether it should be woken up or not. I wake the thread up simply by using the thread\_unblock() function on the my\_thread object stored in curr. Additionally, I also remove it from the list of sleeping threads as it is no longer sleeping. 

### Synchronization 

In order to put the thread to sleep and wake it up, I used the thread\_block() and thread\_unblock() functions respectively. What these functions do is thread\_block() deschedules a thread until it is then rescheduled by its counterpart thread\_unblock(). This is different in comparison to the thread\_yield() function, which can be thought of as immediately descheduling and then rescheduling the target thread.

### Design Justification

One of the goals of this assignment was to implement a more optimized thread\_sleep function that did not waste CPU cycles by busy-waiting. I have achieved this goal as forcing a thread to sleep by blocking it does not count as busy waiting. The implications of this are that the CPU can now schedule other threads while this thread is sleeping, allowing for a more efficient operating system. While the algorithm I wrote to iterate through the sleeping threads list is O(N), where N is the amount of sleeping threads on the system, I figured there would never be a large enough amount of sleeping threads for this to be an issue.  
