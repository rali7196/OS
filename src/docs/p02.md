Rehan Ali and Michael Xiong
CSE 134
May 6th, 2024
Professor Quinn

# Programming Assignment 2 Design Doc

## Command Line Parsing

### Data Structures Created

For the command line parsing, I did not create any new data structures. However, I did edit the thread struct to store its own process id, something I will discuss 
in the next section. 

### Algorithms Used

The algorithm I used for the command line parsing was rather straightforward. It first starts in the process_execute function, where I use the reverse strtok function 
to parse the words by the space delimiter. These are then copied into a char** pointer, where it now needs to be reversed again to be put in the proper order. I do this by iterating through the initial char** pointer backwards and storing them sequentially in another char** pointer. Then, I copy the elements of this new char** pointer back into the old char** pointer. While this may seem a roundabout way to do it, this was to serve as a fix to an earlier problem and this way required the least amount of refactoring. Additionally, because strtok_r also writes null bytes, I had to make another copy of the string and rerun strok_r on it again to ensure that a thread could properly store its own process name within the thread. This is used in the process termination message, which will be discussed later. Moving on, This char** pointer is passed down the function call stack, from start_process to load(), ultimately to setup stack, where all of the arguments are pushed into the esp register via the interrupt frame's esp member. To push all of the relevant information onto the stack, I had to follow the order outlined in the pintos docs, where you first push the strings themselves onto the stack, then a null pointer, then the pointer to the strings, then the pointer to the first argument in argv, then argc, and then finally a fake return address. To do this, I had to calculate the size of each member and ensure I was allocating enough space on the stack via the strlen() and the sizeof operator. Then, I had to make sure the esp pointer was cast appropriately to ensure that the information was stored properly at that particular location. 

## Synchronization Used

I did not use any synchronization primitives for this part of the assignment as every thread has its own stack, and thus there are no data races or conflicts that I need to worry about. 

## Design Justification

I was able to verify the functionality of this design via the hex_dump function. What I would do is after every push to the stack, I would call the hex_dump function as follows:
```
hex_dump((uintptr_t) *esp, *esp, 64, true);
```
What this does is it prints the 64 bytes around the esp pointer register so that I could see if everything was being pushed to the stack properly. I was then able to compare the output with the output shown on the pintos website to ensure that everything was pushed to the stack properly. Another way I was able to verify the functionality of the stack was through reasoning about the amount of space each particular object I was pushing onto the stack was taking. For example, I had to allocate enough space for each string by calculating the length of the string and then decrementing the esp pointer by that particular amount. This is because when the esp pointer is decremented, it can be considered to be pushing onto the stack. Seeing as my design follows the 80x86 calling convention for thread stacks, I can confidently say my design is justified. 