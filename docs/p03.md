Rehan Ali and Michael Xiong <br>
CSE 134<br>
Professor Quinn<br>
May 27, 2023<br>

# Assignment 3 Design Doc

## Paging

### Data Structures Created

In our design we created three new data structures: a supplemental page table, a frame table, and a swap table. The supplemental page table is a hash table consisting of vm_entry structs, which contain the fields location, the address of the supplemental page table entry, the permissions of the page, and the arguments to load_segment and block_read. The idea behind this struct was to store all of the information for a given page so that when it was evicted, it could be recreated. The vm_entry struct was hashed by the address so that it could quickly be accessed. Additionally, the permissions of the page were stored so that in case the page was read only, it could not be modified. The frame table was simply a list that contained a series of frame_entry structs. These contained the address of the frame itself, the pointer to the corresponding vm_entry struct, the owner of the frame, and the list_elem struct. Finally, the swap table we designed involved a bit map, where if a bit was 1 that represented a used sector, and if it was 0 then it was a free sector. The idea behind this was that we could find a continuous section of 8 bits, which would represent a page's worth of space for an evicted page. 

### Synchronization used

For the synchronization we used for paging, we used a lock for the frame table and the swap table and a lock for the page fault exception. The reason for this is that each thread has its own supplemental page table, and thus there will only be 1 writer for each supplemental page table, removing the need for synchronization. Additionally, we need a lock for the frame table and the swap table because there are multiple writers to those data structures. Additionally, we needed a lock for the page fault exception just to ensure that there was only one writer in the critical section of the 
